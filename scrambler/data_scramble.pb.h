// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data_scramble.proto

#ifndef PROTOBUF_data_5fscramble_2eproto__INCLUDED
#define PROTOBUF_data_5fscramble_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace data_scrabmle {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_data_5fscramble_2eproto();
void protobuf_AssignDesc_data_5fscramble_2eproto();
void protobuf_ShutdownFile_data_5fscramble_2eproto();

class frame_scramble;
class field_scramble;
class content_scramble;
class scramble_command;
class frame_output;
class field_additions;
class field_output;
class content_output;
class scramble_response;
class html_element_action;
class html_element_action_response;
class html_element_action_request;

enum scramble_mode {
  FRAME_WEB_PAGE_SCRAMBLE = 0,
  CONTENT_WEB_PAGE_SCRAMBLE = 1,
  CONTENT_WEB_PAGE_HILIGHT = 2
};
bool scramble_mode_IsValid(int value);
const scramble_mode scramble_mode_MIN = FRAME_WEB_PAGE_SCRAMBLE;
const scramble_mode scramble_mode_MAX = CONTENT_WEB_PAGE_HILIGHT;
const int scramble_mode_ARRAYSIZE = scramble_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* scramble_mode_descriptor();
inline const ::std::string& scramble_mode_Name(scramble_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    scramble_mode_descriptor(), value);
}
inline bool scramble_mode_Parse(
    const ::std::string& name, scramble_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<scramble_mode>(
    scramble_mode_descriptor(), name, value);
}
// ===================================================================

class frame_scramble : public ::google::protobuf::Message {
 public:
  frame_scramble();
  virtual ~frame_scramble();

  frame_scramble(const frame_scramble& from);

  inline frame_scramble& operator=(const frame_scramble& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const frame_scramble& default_instance();

  void Swap(frame_scramble* other);

  // implements Message ----------------------------------------------

  frame_scramble* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const frame_scramble& from);
  void MergeFrom(const frame_scramble& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // required string links_xpath = 2;
  inline bool has_links_xpath() const;
  inline void clear_links_xpath();
  static const int kLinksXpathFieldNumber = 2;
  inline const ::std::string& links_xpath() const;
  inline void set_links_xpath(const ::std::string& value);
  inline void set_links_xpath(const char* value);
  inline void set_links_xpath(const char* value, size_t size);
  inline ::std::string* mutable_links_xpath();
  inline ::std::string* release_links_xpath();
  inline void set_allocated_links_xpath(::std::string* links_xpath);

  // required string next_xpath = 3;
  inline bool has_next_xpath() const;
  inline void clear_next_xpath();
  static const int kNextXpathFieldNumber = 3;
  inline const ::std::string& next_xpath() const;
  inline void set_next_xpath(const ::std::string& value);
  inline void set_next_xpath(const char* value);
  inline void set_next_xpath(const char* value, size_t size);
  inline ::std::string* mutable_next_xpath();
  inline ::std::string* release_next_xpath();
  inline void set_allocated_next_xpath(::std::string* next_xpath);

  // @@protoc_insertion_point(class_scope:data_scrabmle.frame_scramble)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_links_xpath();
  inline void clear_has_links_xpath();
  inline void set_has_next_xpath();
  inline void clear_has_next_xpath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::std::string* links_xpath_;
  ::std::string* next_xpath_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static frame_scramble* default_instance_;
};
// -------------------------------------------------------------------

class field_scramble : public ::google::protobuf::Message {
 public:
  field_scramble();
  virtual ~field_scramble();

  field_scramble(const field_scramble& from);

  inline field_scramble& operator=(const field_scramble& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const field_scramble& default_instance();

  void Swap(field_scramble* other);

  // implements Message ----------------------------------------------

  field_scramble* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const field_scramble& from);
  void MergeFrom(const field_scramble& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string xpath = 2;
  inline bool has_xpath() const;
  inline void clear_xpath();
  static const int kXpathFieldNumber = 2;
  inline const ::std::string& xpath() const;
  inline void set_xpath(const ::std::string& value);
  inline void set_xpath(const char* value);
  inline void set_xpath(const char* value, size_t size);
  inline ::std::string* mutable_xpath();
  inline ::std::string* release_xpath();
  inline void set_allocated_xpath(::std::string* xpath);

  // @@protoc_insertion_point(class_scope:data_scrabmle.field_scramble)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_xpath();
  inline void clear_has_xpath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* xpath_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static field_scramble* default_instance_;
};
// -------------------------------------------------------------------

class content_scramble : public ::google::protobuf::Message {
 public:
  content_scramble();
  virtual ~content_scramble();

  content_scramble(const content_scramble& from);

  inline content_scramble& operator=(const content_scramble& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const content_scramble& default_instance();

  void Swap(content_scramble* other);

  // implements Message ----------------------------------------------

  content_scramble* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const content_scramble& from);
  void MergeFrom(const content_scramble& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // repeated .data_scrabmle.field_scramble fields = 3;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 3;
  inline const ::data_scrabmle::field_scramble& fields(int index) const;
  inline ::data_scrabmle::field_scramble* mutable_fields(int index);
  inline ::data_scrabmle::field_scramble* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_scramble >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_scramble >*
      mutable_fields();

  // @@protoc_insertion_point(class_scope:data_scrabmle.content_scramble)
 private:
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_scramble > fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static content_scramble* default_instance_;
};
// -------------------------------------------------------------------

class scramble_command : public ::google::protobuf::Message {
 public:
  scramble_command();
  virtual ~scramble_command();

  scramble_command(const scramble_command& from);

  inline scramble_command& operator=(const scramble_command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scramble_command& default_instance();

  void Swap(scramble_command* other);

  // implements Message ----------------------------------------------

  scramble_command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scramble_command& from);
  void MergeFrom(const scramble_command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .data_scrabmle.scramble_mode mode = 1 [default = FRAME_WEB_PAGE_SCRAMBLE];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::data_scrabmle::scramble_mode mode() const;
  inline void set_mode(::data_scrabmle::scramble_mode value);

  // optional .data_scrabmle.frame_scramble frame = 2;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 2;
  inline const ::data_scrabmle::frame_scramble& frame() const;
  inline ::data_scrabmle::frame_scramble* mutable_frame();
  inline ::data_scrabmle::frame_scramble* release_frame();
  inline void set_allocated_frame(::data_scrabmle::frame_scramble* frame);

  // optional .data_scrabmle.content_scramble content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::data_scrabmle::content_scramble& content() const;
  inline ::data_scrabmle::content_scramble* mutable_content();
  inline ::data_scrabmle::content_scramble* release_content();
  inline void set_allocated_content(::data_scrabmle::content_scramble* content);

  // @@protoc_insertion_point(class_scope:data_scrabmle.scramble_command)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::data_scrabmle::frame_scramble* frame_;
  ::data_scrabmle::content_scramble* content_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static scramble_command* default_instance_;
};
// -------------------------------------------------------------------

class frame_output : public ::google::protobuf::Message {
 public:
  frame_output();
  virtual ~frame_output();

  frame_output(const frame_output& from);

  inline frame_output& operator=(const frame_output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const frame_output& default_instance();

  void Swap(frame_output* other);

  // implements Message ----------------------------------------------

  frame_output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const frame_output& from);
  void MergeFrom(const frame_output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // required string next_link = 2;
  inline bool has_next_link() const;
  inline void clear_next_link();
  static const int kNextLinkFieldNumber = 2;
  inline const ::std::string& next_link() const;
  inline void set_next_link(const ::std::string& value);
  inline void set_next_link(const char* value);
  inline void set_next_link(const char* value, size_t size);
  inline ::std::string* mutable_next_link();
  inline ::std::string* release_next_link();
  inline void set_allocated_next_link(::std::string* next_link);

  // repeated string link = 3;
  inline int link_size() const;
  inline void clear_link();
  static const int kLinkFieldNumber = 3;
  inline const ::std::string& link(int index) const;
  inline ::std::string* mutable_link(int index);
  inline void set_link(int index, const ::std::string& value);
  inline void set_link(int index, const char* value);
  inline void set_link(int index, const char* value, size_t size);
  inline ::std::string* add_link();
  inline void add_link(const ::std::string& value);
  inline void add_link(const char* value);
  inline void add_link(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& link() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link();

  // @@protoc_insertion_point(class_scope:data_scrabmle.frame_output)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_next_link();
  inline void clear_has_next_link();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::std::string* next_link_;
  ::google::protobuf::RepeatedPtrField< ::std::string> link_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static frame_output* default_instance_;
};
// -------------------------------------------------------------------

class field_additions : public ::google::protobuf::Message {
 public:
  field_additions();
  virtual ~field_additions();

  field_additions(const field_additions& from);

  inline field_additions& operator=(const field_additions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const field_additions& default_instance();

  void Swap(field_additions* other);

  // implements Message ----------------------------------------------

  field_additions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const field_additions& from);
  void MergeFrom(const field_additions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string addition = 1;
  inline int addition_size() const;
  inline void clear_addition();
  static const int kAdditionFieldNumber = 1;
  inline const ::std::string& addition(int index) const;
  inline ::std::string* mutable_addition(int index);
  inline void set_addition(int index, const ::std::string& value);
  inline void set_addition(int index, const char* value);
  inline void set_addition(int index, const char* value, size_t size);
  inline ::std::string* add_addition();
  inline void add_addition(const ::std::string& value);
  inline void add_addition(const char* value);
  inline void add_addition(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& addition() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_addition();

  // @@protoc_insertion_point(class_scope:data_scrabmle.field_additions)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> addition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static field_additions* default_instance_;
};
// -------------------------------------------------------------------

class field_output : public ::google::protobuf::Message {
 public:
  field_output();
  virtual ~field_output();

  field_output(const field_output& from);

  inline field_output& operator=(const field_output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const field_output& default_instance();

  void Swap(field_output* other);

  // implements Message ----------------------------------------------

  field_output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const field_output& from);
  void MergeFrom(const field_output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string output = 2;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 2;
  inline const ::std::string& output() const;
  inline void set_output(const ::std::string& value);
  inline void set_output(const char* value);
  inline void set_output(const char* value, size_t size);
  inline ::std::string* mutable_output();
  inline ::std::string* release_output();
  inline void set_allocated_output(::std::string* output);

  // repeated string additions = 3;
  inline int additions_size() const;
  inline void clear_additions();
  static const int kAdditionsFieldNumber = 3;
  inline const ::std::string& additions(int index) const;
  inline ::std::string* mutable_additions(int index);
  inline void set_additions(int index, const ::std::string& value);
  inline void set_additions(int index, const char* value);
  inline void set_additions(int index, const char* value, size_t size);
  inline ::std::string* add_additions();
  inline void add_additions(const ::std::string& value);
  inline void add_additions(const char* value);
  inline void add_additions(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& additions() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_additions();

  // @@protoc_insertion_point(class_scope:data_scrabmle.field_output)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* output_;
  ::google::protobuf::RepeatedPtrField< ::std::string> additions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static field_output* default_instance_;
};
// -------------------------------------------------------------------

class content_output : public ::google::protobuf::Message {
 public:
  content_output();
  virtual ~content_output();

  content_output(const content_output& from);

  inline content_output& operator=(const content_output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const content_output& default_instance();

  void Swap(content_output* other);

  // implements Message ----------------------------------------------

  content_output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const content_output& from);
  void MergeFrom(const content_output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // repeated .data_scrabmle.field_output content = 2;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::data_scrabmle::field_output& content(int index) const;
  inline ::data_scrabmle::field_output* mutable_content(int index);
  inline ::data_scrabmle::field_output* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_output >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_output >*
      mutable_content();

  // @@protoc_insertion_point(class_scope:data_scrabmle.content_output)
 private:
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_output > content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static content_output* default_instance_;
};
// -------------------------------------------------------------------

class scramble_response : public ::google::protobuf::Message {
 public:
  scramble_response();
  virtual ~scramble_response();

  scramble_response(const scramble_response& from);

  inline scramble_response& operator=(const scramble_response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scramble_response& default_instance();

  void Swap(scramble_response* other);

  // implements Message ----------------------------------------------

  scramble_response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scramble_response& from);
  void MergeFrom(const scramble_response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .data_scrabmle.scramble_mode mode = 1 [default = FRAME_WEB_PAGE_SCRAMBLE];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::data_scrabmle::scramble_mode mode() const;
  inline void set_mode(::data_scrabmle::scramble_mode value);

  // optional .data_scrabmle.frame_output frame = 2;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 2;
  inline const ::data_scrabmle::frame_output& frame() const;
  inline ::data_scrabmle::frame_output* mutable_frame();
  inline ::data_scrabmle::frame_output* release_frame();
  inline void set_allocated_frame(::data_scrabmle::frame_output* frame);

  // optional .data_scrabmle.content_output content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::data_scrabmle::content_output& content() const;
  inline ::data_scrabmle::content_output* mutable_content();
  inline ::data_scrabmle::content_output* release_content();
  inline void set_allocated_content(::data_scrabmle::content_output* content);

  // @@protoc_insertion_point(class_scope:data_scrabmle.scramble_response)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::data_scrabmle::frame_output* frame_;
  ::data_scrabmle::content_output* content_;
  int mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static scramble_response* default_instance_;
};
// -------------------------------------------------------------------

class html_element_action : public ::google::protobuf::Message {
 public:
  html_element_action();
  virtual ~html_element_action();

  html_element_action(const html_element_action& from);

  inline html_element_action& operator=(const html_element_action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const html_element_action& default_instance();

  void Swap(html_element_action* other);

  // implements Message ----------------------------------------------

  html_element_action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const html_element_action& from);
  void MergeFrom(const html_element_action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  inline ::std::string* release_action();
  inline void set_allocated_action(::std::string* action);

  // required string xpath = 3;
  inline bool has_xpath() const;
  inline void clear_xpath();
  static const int kXpathFieldNumber = 3;
  inline const ::std::string& xpath() const;
  inline void set_xpath(const ::std::string& value);
  inline void set_xpath(const char* value);
  inline void set_xpath(const char* value, size_t size);
  inline ::std::string* mutable_xpath();
  inline ::std::string* release_xpath();
  inline void set_allocated_xpath(::std::string* xpath);

  // required string param = 4;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 4;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // required string url = 5;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 5;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string input = 6;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 6;
  inline const ::std::string& input() const;
  inline void set_input(const ::std::string& value);
  inline void set_input(const char* value);
  inline void set_input(const char* value, size_t size);
  inline ::std::string* mutable_input();
  inline ::std::string* release_input();
  inline void set_allocated_input(::std::string* input);

  // @@protoc_insertion_point(class_scope:data_scrabmle.html_element_action)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_xpath();
  inline void clear_has_xpath();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_input();
  inline void clear_has_input();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* action_;
  ::std::string* xpath_;
  ::std::string* param_;
  ::std::string* url_;
  ::std::string* input_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static html_element_action* default_instance_;
};
// -------------------------------------------------------------------

class html_element_action_response : public ::google::protobuf::Message {
 public:
  html_element_action_response();
  virtual ~html_element_action_response();

  html_element_action_response(const html_element_action_response& from);

  inline html_element_action_response& operator=(const html_element_action_response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const html_element_action_response& default_instance();

  void Swap(html_element_action_response* other);

  // implements Message ----------------------------------------------

  html_element_action_response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const html_element_action_response& from);
  void MergeFrom(const html_element_action_response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated string response = 2;
  inline int response_size() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::std::string& response(int index) const;
  inline ::std::string* mutable_response(int index);
  inline void set_response(int index, const ::std::string& value);
  inline void set_response(int index, const char* value);
  inline void set_response(int index, const char* value, size_t size);
  inline ::std::string* add_response();
  inline void add_response(const ::std::string& value);
  inline void add_response(const char* value);
  inline void add_response(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& response() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_response();

  // @@protoc_insertion_point(class_scope:data_scrabmle.html_element_action_response)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static html_element_action_response* default_instance_;
};
// -------------------------------------------------------------------

class html_element_action_request : public ::google::protobuf::Message {
 public:
  html_element_action_request();
  virtual ~html_element_action_request();

  html_element_action_request(const html_element_action_request& from);

  inline html_element_action_request& operator=(const html_element_action_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const html_element_action_request& default_instance();

  void Swap(html_element_action_request* other);

  // implements Message ----------------------------------------------

  html_element_action_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const html_element_action_request& from);
  void MergeFrom(const html_element_action_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const char* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  inline void set_allocated_request(::std::string* request);

  // @@protoc_insertion_point(class_scope:data_scrabmle.html_element_action_request)
 private:
  inline void set_has_request();
  inline void clear_has_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_data_5fscramble_2eproto();
  friend void protobuf_AssignDesc_data_5fscramble_2eproto();
  friend void protobuf_ShutdownFile_data_5fscramble_2eproto();

  void InitAsDefaultInstance();
  static html_element_action_request* default_instance_;
};
// ===================================================================


// ===================================================================

// frame_scramble

// required string url = 1;
inline bool frame_scramble::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void frame_scramble::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void frame_scramble::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void frame_scramble::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& frame_scramble::url() const {
  return *url_;
}
inline void frame_scramble::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void frame_scramble::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void frame_scramble::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* frame_scramble::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* frame_scramble::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void frame_scramble::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string links_xpath = 2;
inline bool frame_scramble::has_links_xpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void frame_scramble::set_has_links_xpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void frame_scramble::clear_has_links_xpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void frame_scramble::clear_links_xpath() {
  if (links_xpath_ != &::google::protobuf::internal::kEmptyString) {
    links_xpath_->clear();
  }
  clear_has_links_xpath();
}
inline const ::std::string& frame_scramble::links_xpath() const {
  return *links_xpath_;
}
inline void frame_scramble::set_links_xpath(const ::std::string& value) {
  set_has_links_xpath();
  if (links_xpath_ == &::google::protobuf::internal::kEmptyString) {
    links_xpath_ = new ::std::string;
  }
  links_xpath_->assign(value);
}
inline void frame_scramble::set_links_xpath(const char* value) {
  set_has_links_xpath();
  if (links_xpath_ == &::google::protobuf::internal::kEmptyString) {
    links_xpath_ = new ::std::string;
  }
  links_xpath_->assign(value);
}
inline void frame_scramble::set_links_xpath(const char* value, size_t size) {
  set_has_links_xpath();
  if (links_xpath_ == &::google::protobuf::internal::kEmptyString) {
    links_xpath_ = new ::std::string;
  }
  links_xpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* frame_scramble::mutable_links_xpath() {
  set_has_links_xpath();
  if (links_xpath_ == &::google::protobuf::internal::kEmptyString) {
    links_xpath_ = new ::std::string;
  }
  return links_xpath_;
}
inline ::std::string* frame_scramble::release_links_xpath() {
  clear_has_links_xpath();
  if (links_xpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = links_xpath_;
    links_xpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void frame_scramble::set_allocated_links_xpath(::std::string* links_xpath) {
  if (links_xpath_ != &::google::protobuf::internal::kEmptyString) {
    delete links_xpath_;
  }
  if (links_xpath) {
    set_has_links_xpath();
    links_xpath_ = links_xpath;
  } else {
    clear_has_links_xpath();
    links_xpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string next_xpath = 3;
inline bool frame_scramble::has_next_xpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void frame_scramble::set_has_next_xpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void frame_scramble::clear_has_next_xpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void frame_scramble::clear_next_xpath() {
  if (next_xpath_ != &::google::protobuf::internal::kEmptyString) {
    next_xpath_->clear();
  }
  clear_has_next_xpath();
}
inline const ::std::string& frame_scramble::next_xpath() const {
  return *next_xpath_;
}
inline void frame_scramble::set_next_xpath(const ::std::string& value) {
  set_has_next_xpath();
  if (next_xpath_ == &::google::protobuf::internal::kEmptyString) {
    next_xpath_ = new ::std::string;
  }
  next_xpath_->assign(value);
}
inline void frame_scramble::set_next_xpath(const char* value) {
  set_has_next_xpath();
  if (next_xpath_ == &::google::protobuf::internal::kEmptyString) {
    next_xpath_ = new ::std::string;
  }
  next_xpath_->assign(value);
}
inline void frame_scramble::set_next_xpath(const char* value, size_t size) {
  set_has_next_xpath();
  if (next_xpath_ == &::google::protobuf::internal::kEmptyString) {
    next_xpath_ = new ::std::string;
  }
  next_xpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* frame_scramble::mutable_next_xpath() {
  set_has_next_xpath();
  if (next_xpath_ == &::google::protobuf::internal::kEmptyString) {
    next_xpath_ = new ::std::string;
  }
  return next_xpath_;
}
inline ::std::string* frame_scramble::release_next_xpath() {
  clear_has_next_xpath();
  if (next_xpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_xpath_;
    next_xpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void frame_scramble::set_allocated_next_xpath(::std::string* next_xpath) {
  if (next_xpath_ != &::google::protobuf::internal::kEmptyString) {
    delete next_xpath_;
  }
  if (next_xpath) {
    set_has_next_xpath();
    next_xpath_ = next_xpath;
  } else {
    clear_has_next_xpath();
    next_xpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// field_scramble

// required string name = 1;
inline bool field_scramble::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void field_scramble::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void field_scramble::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void field_scramble::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& field_scramble::name() const {
  return *name_;
}
inline void field_scramble::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void field_scramble::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void field_scramble::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* field_scramble::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* field_scramble::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void field_scramble::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string xpath = 2;
inline bool field_scramble::has_xpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void field_scramble::set_has_xpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void field_scramble::clear_has_xpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void field_scramble::clear_xpath() {
  if (xpath_ != &::google::protobuf::internal::kEmptyString) {
    xpath_->clear();
  }
  clear_has_xpath();
}
inline const ::std::string& field_scramble::xpath() const {
  return *xpath_;
}
inline void field_scramble::set_xpath(const ::std::string& value) {
  set_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    xpath_ = new ::std::string;
  }
  xpath_->assign(value);
}
inline void field_scramble::set_xpath(const char* value) {
  set_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    xpath_ = new ::std::string;
  }
  xpath_->assign(value);
}
inline void field_scramble::set_xpath(const char* value, size_t size) {
  set_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    xpath_ = new ::std::string;
  }
  xpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* field_scramble::mutable_xpath() {
  set_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    xpath_ = new ::std::string;
  }
  return xpath_;
}
inline ::std::string* field_scramble::release_xpath() {
  clear_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xpath_;
    xpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void field_scramble::set_allocated_xpath(::std::string* xpath) {
  if (xpath_ != &::google::protobuf::internal::kEmptyString) {
    delete xpath_;
  }
  if (xpath) {
    set_has_xpath();
    xpath_ = xpath;
  } else {
    clear_has_xpath();
    xpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// content_scramble

// required string url = 2;
inline bool content_scramble::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void content_scramble::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void content_scramble::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void content_scramble::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& content_scramble::url() const {
  return *url_;
}
inline void content_scramble::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void content_scramble::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void content_scramble::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* content_scramble::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* content_scramble::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void content_scramble::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .data_scrabmle.field_scramble fields = 3;
inline int content_scramble::fields_size() const {
  return fields_.size();
}
inline void content_scramble::clear_fields() {
  fields_.Clear();
}
inline const ::data_scrabmle::field_scramble& content_scramble::fields(int index) const {
  return fields_.Get(index);
}
inline ::data_scrabmle::field_scramble* content_scramble::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline ::data_scrabmle::field_scramble* content_scramble::add_fields() {
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_scramble >&
content_scramble::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_scramble >*
content_scramble::mutable_fields() {
  return &fields_;
}

// -------------------------------------------------------------------

// scramble_command

// required .data_scrabmle.scramble_mode mode = 1 [default = FRAME_WEB_PAGE_SCRAMBLE];
inline bool scramble_command::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scramble_command::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scramble_command::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scramble_command::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::data_scrabmle::scramble_mode scramble_command::mode() const {
  return static_cast< ::data_scrabmle::scramble_mode >(mode_);
}
inline void scramble_command::set_mode(::data_scrabmle::scramble_mode value) {
  assert(::data_scrabmle::scramble_mode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional .data_scrabmle.frame_scramble frame = 2;
inline bool scramble_command::has_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void scramble_command::set_has_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void scramble_command::clear_has_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void scramble_command::clear_frame() {
  if (frame_ != NULL) frame_->::data_scrabmle::frame_scramble::Clear();
  clear_has_frame();
}
inline const ::data_scrabmle::frame_scramble& scramble_command::frame() const {
  return frame_ != NULL ? *frame_ : *default_instance_->frame_;
}
inline ::data_scrabmle::frame_scramble* scramble_command::mutable_frame() {
  set_has_frame();
  if (frame_ == NULL) frame_ = new ::data_scrabmle::frame_scramble;
  return frame_;
}
inline ::data_scrabmle::frame_scramble* scramble_command::release_frame() {
  clear_has_frame();
  ::data_scrabmle::frame_scramble* temp = frame_;
  frame_ = NULL;
  return temp;
}
inline void scramble_command::set_allocated_frame(::data_scrabmle::frame_scramble* frame) {
  delete frame_;
  frame_ = frame;
  if (frame) {
    set_has_frame();
  } else {
    clear_has_frame();
  }
}

// optional .data_scrabmle.content_scramble content = 3;
inline bool scramble_command::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void scramble_command::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void scramble_command::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void scramble_command::clear_content() {
  if (content_ != NULL) content_->::data_scrabmle::content_scramble::Clear();
  clear_has_content();
}
inline const ::data_scrabmle::content_scramble& scramble_command::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::data_scrabmle::content_scramble* scramble_command::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::data_scrabmle::content_scramble;
  return content_;
}
inline ::data_scrabmle::content_scramble* scramble_command::release_content() {
  clear_has_content();
  ::data_scrabmle::content_scramble* temp = content_;
  content_ = NULL;
  return temp;
}
inline void scramble_command::set_allocated_content(::data_scrabmle::content_scramble* content) {
  delete content_;
  content_ = content;
  if (content) {
    set_has_content();
  } else {
    clear_has_content();
  }
}

// -------------------------------------------------------------------

// frame_output

// required string url = 1;
inline bool frame_output::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void frame_output::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void frame_output::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void frame_output::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& frame_output::url() const {
  return *url_;
}
inline void frame_output::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void frame_output::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void frame_output::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* frame_output::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* frame_output::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void frame_output::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string next_link = 2;
inline bool frame_output::has_next_link() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void frame_output::set_has_next_link() {
  _has_bits_[0] |= 0x00000002u;
}
inline void frame_output::clear_has_next_link() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void frame_output::clear_next_link() {
  if (next_link_ != &::google::protobuf::internal::kEmptyString) {
    next_link_->clear();
  }
  clear_has_next_link();
}
inline const ::std::string& frame_output::next_link() const {
  return *next_link_;
}
inline void frame_output::set_next_link(const ::std::string& value) {
  set_has_next_link();
  if (next_link_ == &::google::protobuf::internal::kEmptyString) {
    next_link_ = new ::std::string;
  }
  next_link_->assign(value);
}
inline void frame_output::set_next_link(const char* value) {
  set_has_next_link();
  if (next_link_ == &::google::protobuf::internal::kEmptyString) {
    next_link_ = new ::std::string;
  }
  next_link_->assign(value);
}
inline void frame_output::set_next_link(const char* value, size_t size) {
  set_has_next_link();
  if (next_link_ == &::google::protobuf::internal::kEmptyString) {
    next_link_ = new ::std::string;
  }
  next_link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* frame_output::mutable_next_link() {
  set_has_next_link();
  if (next_link_ == &::google::protobuf::internal::kEmptyString) {
    next_link_ = new ::std::string;
  }
  return next_link_;
}
inline ::std::string* frame_output::release_next_link() {
  clear_has_next_link();
  if (next_link_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_link_;
    next_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void frame_output::set_allocated_next_link(::std::string* next_link) {
  if (next_link_ != &::google::protobuf::internal::kEmptyString) {
    delete next_link_;
  }
  if (next_link) {
    set_has_next_link();
    next_link_ = next_link;
  } else {
    clear_has_next_link();
    next_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string link = 3;
inline int frame_output::link_size() const {
  return link_.size();
}
inline void frame_output::clear_link() {
  link_.Clear();
}
inline const ::std::string& frame_output::link(int index) const {
  return link_.Get(index);
}
inline ::std::string* frame_output::mutable_link(int index) {
  return link_.Mutable(index);
}
inline void frame_output::set_link(int index, const ::std::string& value) {
  link_.Mutable(index)->assign(value);
}
inline void frame_output::set_link(int index, const char* value) {
  link_.Mutable(index)->assign(value);
}
inline void frame_output::set_link(int index, const char* value, size_t size) {
  link_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* frame_output::add_link() {
  return link_.Add();
}
inline void frame_output::add_link(const ::std::string& value) {
  link_.Add()->assign(value);
}
inline void frame_output::add_link(const char* value) {
  link_.Add()->assign(value);
}
inline void frame_output::add_link(const char* value, size_t size) {
  link_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
frame_output::link() const {
  return link_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
frame_output::mutable_link() {
  return &link_;
}

// -------------------------------------------------------------------

// field_additions

// repeated string addition = 1;
inline int field_additions::addition_size() const {
  return addition_.size();
}
inline void field_additions::clear_addition() {
  addition_.Clear();
}
inline const ::std::string& field_additions::addition(int index) const {
  return addition_.Get(index);
}
inline ::std::string* field_additions::mutable_addition(int index) {
  return addition_.Mutable(index);
}
inline void field_additions::set_addition(int index, const ::std::string& value) {
  addition_.Mutable(index)->assign(value);
}
inline void field_additions::set_addition(int index, const char* value) {
  addition_.Mutable(index)->assign(value);
}
inline void field_additions::set_addition(int index, const char* value, size_t size) {
  addition_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* field_additions::add_addition() {
  return addition_.Add();
}
inline void field_additions::add_addition(const ::std::string& value) {
  addition_.Add()->assign(value);
}
inline void field_additions::add_addition(const char* value) {
  addition_.Add()->assign(value);
}
inline void field_additions::add_addition(const char* value, size_t size) {
  addition_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
field_additions::addition() const {
  return addition_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
field_additions::mutable_addition() {
  return &addition_;
}

// -------------------------------------------------------------------

// field_output

// required string name = 1;
inline bool field_output::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void field_output::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void field_output::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void field_output::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& field_output::name() const {
  return *name_;
}
inline void field_output::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void field_output::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void field_output::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* field_output::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* field_output::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void field_output::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string output = 2;
inline bool field_output::has_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void field_output::set_has_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void field_output::clear_has_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void field_output::clear_output() {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    output_->clear();
  }
  clear_has_output();
}
inline const ::std::string& field_output::output() const {
  return *output_;
}
inline void field_output::set_output(const ::std::string& value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void field_output::set_output(const char* value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void field_output::set_output(const char* value, size_t size) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* field_output::mutable_output() {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  return output_;
}
inline ::std::string* field_output::release_output() {
  clear_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = output_;
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void field_output::set_allocated_output(::std::string* output) {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    delete output_;
  }
  if (output) {
    set_has_output();
    output_ = output;
  } else {
    clear_has_output();
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string additions = 3;
inline int field_output::additions_size() const {
  return additions_.size();
}
inline void field_output::clear_additions() {
  additions_.Clear();
}
inline const ::std::string& field_output::additions(int index) const {
  return additions_.Get(index);
}
inline ::std::string* field_output::mutable_additions(int index) {
  return additions_.Mutable(index);
}
inline void field_output::set_additions(int index, const ::std::string& value) {
  additions_.Mutable(index)->assign(value);
}
inline void field_output::set_additions(int index, const char* value) {
  additions_.Mutable(index)->assign(value);
}
inline void field_output::set_additions(int index, const char* value, size_t size) {
  additions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* field_output::add_additions() {
  return additions_.Add();
}
inline void field_output::add_additions(const ::std::string& value) {
  additions_.Add()->assign(value);
}
inline void field_output::add_additions(const char* value) {
  additions_.Add()->assign(value);
}
inline void field_output::add_additions(const char* value, size_t size) {
  additions_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
field_output::additions() const {
  return additions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
field_output::mutable_additions() {
  return &additions_;
}

// -------------------------------------------------------------------

// content_output

// required string url = 1;
inline bool content_output::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void content_output::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void content_output::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void content_output::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& content_output::url() const {
  return *url_;
}
inline void content_output::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void content_output::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void content_output::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* content_output::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* content_output::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void content_output::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .data_scrabmle.field_output content = 2;
inline int content_output::content_size() const {
  return content_.size();
}
inline void content_output::clear_content() {
  content_.Clear();
}
inline const ::data_scrabmle::field_output& content_output::content(int index) const {
  return content_.Get(index);
}
inline ::data_scrabmle::field_output* content_output::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::data_scrabmle::field_output* content_output::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_output >&
content_output::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::data_scrabmle::field_output >*
content_output::mutable_content() {
  return &content_;
}

// -------------------------------------------------------------------

// scramble_response

// required .data_scrabmle.scramble_mode mode = 1 [default = FRAME_WEB_PAGE_SCRAMBLE];
inline bool scramble_response::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scramble_response::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scramble_response::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scramble_response::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::data_scrabmle::scramble_mode scramble_response::mode() const {
  return static_cast< ::data_scrabmle::scramble_mode >(mode_);
}
inline void scramble_response::set_mode(::data_scrabmle::scramble_mode value) {
  assert(::data_scrabmle::scramble_mode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional .data_scrabmle.frame_output frame = 2;
inline bool scramble_response::has_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void scramble_response::set_has_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void scramble_response::clear_has_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void scramble_response::clear_frame() {
  if (frame_ != NULL) frame_->::data_scrabmle::frame_output::Clear();
  clear_has_frame();
}
inline const ::data_scrabmle::frame_output& scramble_response::frame() const {
  return frame_ != NULL ? *frame_ : *default_instance_->frame_;
}
inline ::data_scrabmle::frame_output* scramble_response::mutable_frame() {
  set_has_frame();
  if (frame_ == NULL) frame_ = new ::data_scrabmle::frame_output;
  return frame_;
}
inline ::data_scrabmle::frame_output* scramble_response::release_frame() {
  clear_has_frame();
  ::data_scrabmle::frame_output* temp = frame_;
  frame_ = NULL;
  return temp;
}
inline void scramble_response::set_allocated_frame(::data_scrabmle::frame_output* frame) {
  delete frame_;
  frame_ = frame;
  if (frame) {
    set_has_frame();
  } else {
    clear_has_frame();
  }
}

// optional .data_scrabmle.content_output content = 3;
inline bool scramble_response::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void scramble_response::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void scramble_response::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void scramble_response::clear_content() {
  if (content_ != NULL) content_->::data_scrabmle::content_output::Clear();
  clear_has_content();
}
inline const ::data_scrabmle::content_output& scramble_response::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::data_scrabmle::content_output* scramble_response::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::data_scrabmle::content_output;
  return content_;
}
inline ::data_scrabmle::content_output* scramble_response::release_content() {
  clear_has_content();
  ::data_scrabmle::content_output* temp = content_;
  content_ = NULL;
  return temp;
}
inline void scramble_response::set_allocated_content(::data_scrabmle::content_output* content) {
  delete content_;
  content_ = content;
  if (content) {
    set_has_content();
  } else {
    clear_has_content();
  }
}

// -------------------------------------------------------------------

// html_element_action

// required string id = 1;
inline bool html_element_action::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void html_element_action::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void html_element_action::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void html_element_action::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& html_element_action::id() const {
  return *id_;
}
inline void html_element_action::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void html_element_action::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void html_element_action::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* html_element_action::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void html_element_action::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string action = 2;
inline bool html_element_action::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void html_element_action::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void html_element_action::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void html_element_action::clear_action() {
  if (action_ != &::google::protobuf::internal::kEmptyString) {
    action_->clear();
  }
  clear_has_action();
}
inline const ::std::string& html_element_action::action() const {
  return *action_;
}
inline void html_element_action::set_action(const ::std::string& value) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void html_element_action::set_action(const char* value) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    action_ = new ::std::string;
  }
  action_->assign(value);
}
inline void html_element_action::set_action(const char* value, size_t size) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    action_ = new ::std::string;
  }
  action_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action::mutable_action() {
  set_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    action_ = new ::std::string;
  }
  return action_;
}
inline ::std::string* html_element_action::release_action() {
  clear_has_action();
  if (action_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = action_;
    action_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void html_element_action::set_allocated_action(::std::string* action) {
  if (action_ != &::google::protobuf::internal::kEmptyString) {
    delete action_;
  }
  if (action) {
    set_has_action();
    action_ = action;
  } else {
    clear_has_action();
    action_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string xpath = 3;
inline bool html_element_action::has_xpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void html_element_action::set_has_xpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void html_element_action::clear_has_xpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void html_element_action::clear_xpath() {
  if (xpath_ != &::google::protobuf::internal::kEmptyString) {
    xpath_->clear();
  }
  clear_has_xpath();
}
inline const ::std::string& html_element_action::xpath() const {
  return *xpath_;
}
inline void html_element_action::set_xpath(const ::std::string& value) {
  set_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    xpath_ = new ::std::string;
  }
  xpath_->assign(value);
}
inline void html_element_action::set_xpath(const char* value) {
  set_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    xpath_ = new ::std::string;
  }
  xpath_->assign(value);
}
inline void html_element_action::set_xpath(const char* value, size_t size) {
  set_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    xpath_ = new ::std::string;
  }
  xpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action::mutable_xpath() {
  set_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    xpath_ = new ::std::string;
  }
  return xpath_;
}
inline ::std::string* html_element_action::release_xpath() {
  clear_has_xpath();
  if (xpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xpath_;
    xpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void html_element_action::set_allocated_xpath(::std::string* xpath) {
  if (xpath_ != &::google::protobuf::internal::kEmptyString) {
    delete xpath_;
  }
  if (xpath) {
    set_has_xpath();
    xpath_ = xpath;
  } else {
    clear_has_xpath();
    xpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string param = 4;
inline bool html_element_action::has_param() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void html_element_action::set_has_param() {
  _has_bits_[0] |= 0x00000008u;
}
inline void html_element_action::clear_has_param() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void html_element_action::clear_param() {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    param_->clear();
  }
  clear_has_param();
}
inline const ::std::string& html_element_action::param() const {
  return *param_;
}
inline void html_element_action::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void html_element_action::set_param(const char* value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void html_element_action::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action::mutable_param() {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  return param_;
}
inline ::std::string* html_element_action::release_param() {
  clear_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void html_element_action::set_allocated_param(::std::string* param) {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string url = 5;
inline bool html_element_action::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void html_element_action::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void html_element_action::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void html_element_action::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& html_element_action::url() const {
  return *url_;
}
inline void html_element_action::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void html_element_action::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void html_element_action::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* html_element_action::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void html_element_action::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string input = 6;
inline bool html_element_action::has_input() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void html_element_action::set_has_input() {
  _has_bits_[0] |= 0x00000020u;
}
inline void html_element_action::clear_has_input() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void html_element_action::clear_input() {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    input_->clear();
  }
  clear_has_input();
}
inline const ::std::string& html_element_action::input() const {
  return *input_;
}
inline void html_element_action::set_input(const ::std::string& value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void html_element_action::set_input(const char* value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void html_element_action::set_input(const char* value, size_t size) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action::mutable_input() {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  return input_;
}
inline ::std::string* html_element_action::release_input() {
  clear_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = input_;
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void html_element_action::set_allocated_input(::std::string* input) {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    delete input_;
  }
  if (input) {
    set_has_input();
    input_ = input;
  } else {
    clear_has_input();
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// html_element_action_response

// required string id = 1;
inline bool html_element_action_response::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void html_element_action_response::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void html_element_action_response::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void html_element_action_response::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& html_element_action_response::id() const {
  return *id_;
}
inline void html_element_action_response::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void html_element_action_response::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void html_element_action_response::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action_response::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* html_element_action_response::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void html_element_action_response::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string response = 2;
inline int html_element_action_response::response_size() const {
  return response_.size();
}
inline void html_element_action_response::clear_response() {
  response_.Clear();
}
inline const ::std::string& html_element_action_response::response(int index) const {
  return response_.Get(index);
}
inline ::std::string* html_element_action_response::mutable_response(int index) {
  return response_.Mutable(index);
}
inline void html_element_action_response::set_response(int index, const ::std::string& value) {
  response_.Mutable(index)->assign(value);
}
inline void html_element_action_response::set_response(int index, const char* value) {
  response_.Mutable(index)->assign(value);
}
inline void html_element_action_response::set_response(int index, const char* value, size_t size) {
  response_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action_response::add_response() {
  return response_.Add();
}
inline void html_element_action_response::add_response(const ::std::string& value) {
  response_.Add()->assign(value);
}
inline void html_element_action_response::add_response(const char* value) {
  response_.Add()->assign(value);
}
inline void html_element_action_response::add_response(const char* value, size_t size) {
  response_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
html_element_action_response::response() const {
  return response_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
html_element_action_response::mutable_response() {
  return &response_;
}

// -------------------------------------------------------------------

// html_element_action_request

// required string request = 1;
inline bool html_element_action_request::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void html_element_action_request::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void html_element_action_request::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void html_element_action_request::clear_request() {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& html_element_action_request::request() const {
  return *request_;
}
inline void html_element_action_request::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void html_element_action_request::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void html_element_action_request::set_request(const char* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* html_element_action_request::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  return request_;
}
inline ::std::string* html_element_action_request::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void html_element_action_request::set_allocated_request(::std::string* request) {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    delete request_;
  }
  if (request) {
    set_has_request();
    request_ = request;
  } else {
    clear_has_request();
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace data_scrabmle

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::data_scrabmle::scramble_mode>() {
  return ::data_scrabmle::scramble_mode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_data_5fscramble_2eproto__INCLUDED
